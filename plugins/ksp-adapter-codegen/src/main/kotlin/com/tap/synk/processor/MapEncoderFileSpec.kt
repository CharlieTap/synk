package com.tap.synk.processor

import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSFile
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.symbol.KSValueParameter
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.addOriginatingKSFile
import com.squareup.kotlinpoet.ksp.toTypeName

context(ProcessorContext)
internal fun mapEncoderFileSpec(
    packageName: String,
    fileName: String,
    genericType: KSType,
    originatingFile: KSFile
) = FileSpec.builder(
    packageName = packageName,
    fileName = fileName
).apply {

    val classDeclaration = (genericType.declaration as? KSClassDeclaration) ?: run {
        logger.error("Failed to find class declaration for type", genericType.declaration)
        throw IllegalStateException("")
    }

    indent("    ")
    addFileComment("Code generated by SynkAdapter plugin. Do not edit this file.")
    addType(
       mapEncoderTypeSpec(
           fileName,
           genericType.toTypeName(),
           encodeFunCodeBlock(classDeclaration),
           decodeFunCodeBlock(classDeclaration),
           originatingFile
       )
    )
}.build()

context(ProcessorContext)
internal fun mapEncoderTypeSpec(
    fileName: String,
    genericTypeName: TypeName,
    encodeFunCodeBlock: CodeBlock,
    decodeFunCodeBlock: CodeBlock,
    originatingFile: KSFile,
    primaryConstructor: FunSpec? = null
): TypeSpec {
    return TypeSpec.classBuilder(fileName).apply {
        primaryConstructor?.let { funSpec ->
            primaryConstructor(funSpec)
        }
        addSuperinterface(poetTypes.parameterizedMapEncoder(genericTypeName))
        addFunction(
            FunSpec
                .builder("encode")
                .addModifiers(KModifier.OVERRIDE)
                .addParameter("crdt", genericTypeName)
                .returns(poetTypes.stringMapTypeName)
                .addCode(encodeFunCodeBlock)
                .build()
        )
        addFunction(
            FunSpec
                .builder("decode")
                .addModifiers(KModifier.OVERRIDE)
                .addParameter("map", poetTypes.stringMapTypeName)
                .returns(genericTypeName)
                .addCode(decodeFunCodeBlock)
                .build()
        )
        addOriginatingKSFile(originatingFile)
    }.build()

}

context(ProcessorContext)
private fun encodeFunCodeBlock(classDeclaration: KSClassDeclaration) : CodeBlock {
    val constructor = classDeclaration.primaryConstructor ?: run {
        logger.error("Failed to constructor for ${classDeclaration.simpleName.asString()}", classDeclaration)
        return CodeBlock.of("")
    }

    val statements = constructor.parameters.map { param ->
        val name = param.key()
        val type = param.type.resolve()

        val conversion = if(symbols.isComposite(type)) {
            logger.warn("Synk Adapter Plugin does not currently support generating encoders for classes with nested classes or array properties", param)
            ""
        } else {
            if(!symbols.isString(type)) {
                ".toString()"
            } else ""
        }

        "map[\"$name\"] = crdt.$name$conversion"
    }

    return CodeBlock.builder().apply {
        addStatement("val map = mutableMapOf<String, String>()")
        statements.forEach { statement ->
            addStatement(statement)
        }
        addStatement("return map")
    }.build()
}

context(ProcessorContext)
private fun decodeFunCodeBlock(classDeclaration: KSClassDeclaration) : CodeBlock {
    val constructor = classDeclaration.primaryConstructor ?: run {
        logger.error("Failed to constructor for ${classDeclaration.simpleName.asString()}", classDeclaration)
        return CodeBlock.of("")
    }

    val statement = constructor.parameters.foldIndexed("map[\"") { idx, acc, param ->
        val conversion = symbols.stringDecodeFunction(param.type.resolve())
        val postfix = if(idx == constructor.parameters.size - 1) {
            "\"]!!$conversion"
        } else "\"]!!$conversion, map[\""

        acc + param.name?.asString() + postfix
    }

    return CodeBlock.builder().apply {
        addStatement("val crdt = %L(%L)", classDeclaration.simpleName.asString(), statement)
        addStatement("return crdt")
    }.build()
}


context(ProcessorContext)
private fun KSValueParameter.key() : String {
    return if(symbols.isComposite(type.resolve())) {
        logger.warn("Map key serialization of Composite structs unavailable")
        ""
    } else {
        name?.asString() ?: ""
    }
}


