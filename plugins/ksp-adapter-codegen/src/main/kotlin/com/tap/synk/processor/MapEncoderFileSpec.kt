package com.tap.synk.processor

import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSFile
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.symbol.KSValueParameter
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.addOriginatingKSFile
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.toTypeName

context(ProcessorContext)
internal fun mapEncoderFileSpec(
    packageName: String,
    fileName: String,
    genericType: KSType,
    originatingFile: KSFile
) = FileSpec.builder(
    packageName = packageName,
    fileName = fileName
).apply {

    val classDeclaration = (genericType.declaration as? KSClassDeclaration) ?: run {
        logger.error("Failed to find class declaration for type", genericType.declaration)
        throw IllegalStateException("")
    }

    indent("    ")
    addFileComment("Code generated by SynkAdapter plugin. Do not edit this file.")
    addType(
       mapEncoderTypeSpec(
           fileName,
           genericType.toTypeName(),
           encodeFunCodeBlock(classDeclaration),
           decodeFunCodeBlock(classDeclaration),
           originatingFile
       )
    )
}.build()

/**
 * public class FooMapEncoder : MapEncoder<Foo> {
 *      public override fun encode(crdt: Foo): Map<String, String> {
 *              val map = mutableMapOf<String, String>()
 *              map["bar"] = crdt.bar
 *              map["baz"] = crdt.baz.toString()
 *              map["bim"] = crdt.bim.toString()
 *              return map
 *      }
 *
 *      public override fun decode(map: Map<String, String>): Foo {
 *              val crdt = Foo(map["bar"]!!, map["baz"]!!.toInt(), map["bim"]!!.toBoolean())
 *              return crdt
 *      }
 * }
 */
context(ProcessorContext)
internal fun mapEncoderTypeSpec(
    fileName: String,
    genericTypeName: TypeName,
    encodeFunCodeBlock: CodeBlock,
    decodeFunCodeBlock: CodeBlock,
    originatingFile: KSFile,
    primaryConstructor: FunSpec? = null,
    properties: List<PropertySpec> = emptyList()
): TypeSpec {
    return TypeSpec.classBuilder(fileName).apply {
        primaryConstructor?.let { funSpec ->
            primaryConstructor(funSpec)
        }
        properties.forEach { propertySpec ->
            addProperty(propertySpec)
        }
        addSuperinterface(poetTypes.parameterizedMapEncoder(genericTypeName))
        addFunction(
            FunSpec
                .builder("encode")
                .addModifiers(KModifier.OVERRIDE)
                .addParameter("crdt", genericTypeName)
                .returns(poetTypes.stringMapTypeName)
                .addCode(encodeFunCodeBlock)
                .build()
        )
        addFunction(
            FunSpec
                .builder("decode")
                .addModifiers(KModifier.OVERRIDE)
                .addParameter("map", poetTypes.stringMapTypeName)
                .returns(genericTypeName)
                .addCode(decodeFunCodeBlock)
                .build()
        )
        addOriginatingKSFile(originatingFile)
    }.build()

}

/**
 * public override fun encode(crdt: Foo): Map<String, String> {
 *      val map = mutableMapOf<String, String>()
 *      map["bar"] = crdt.bar
 *      map["baz"] = crdt.baz.toString()
 *      map["bim"] = crdt.bim.toString()
 *      return map
 * }
 */
context(ProcessorContext)
private fun encodeFunCodeBlock(classDeclaration: KSClassDeclaration) : CodeBlock {
    val constructor = classDeclaration.primaryConstructor ?: run {
        logger.error("Failed to constructor for ${classDeclaration.simpleName.asString()}", classDeclaration)
        return CodeBlock.of("")
    }

    val statements = constructor.parameters.map { param ->

        val name = param.name?.asString() ?: run {
            logger.error("Synk Adapter Plugin failed to get name of parameter", param)
            ""
        }
        val key = param.key()
        val type = param.type.resolve()

        val conversion = if(symbols.isCollectionOrArray(type)) {
            logger.error("Synk Adapter Plugin does not currently support generating encoders for classes with nested classes or array properties", param)
            ""
        } else if(symbols.isUserDefinedType(type)) {
            logger.error("Synk Adapter Plugin does not currently support generating encoders for classes with nested classes or array properties", param)
            ""
        } else {
            if(!symbols.isString(type)) {
                ".toString()"
            } else ""
        }

        "map[\"$key\"] = crdt.$name$conversion"
    }

    return CodeBlock.builder().apply {
        addStatement("val map = mutableMapOf<String, String>()")
        statements.forEach { statement ->
            addStatement(statement)
        }
        addStatement("return map")
    }.build()
}

/**
 * public override fun decode(map: Map<String, String>): Foo {
 *      val crdt = Foo(map["bar"]!!, map["baz"]!!.toInt(), map["bim"]!!.toBoolean())
 *      return crdt
 * }
 */
context(ProcessorContext)
private fun decodeFunCodeBlock(classDeclaration: KSClassDeclaration) : CodeBlock {
    val constructor = classDeclaration.primaryConstructor ?: run {
        logger.error("Failed to constructor for ${classDeclaration.simpleName.asString()}", classDeclaration)
        return CodeBlock.of("")
    }

    val statement = constructor.parameters.foldIndexed("map[\"") { idx, acc, param ->
        val conversion = symbols.stringDecodeFunction(param.type.resolve())
        val postfix = if(idx == constructor.parameters.size - 1) {
            "\"]!!$conversion"
        } else "\"]!!$conversion, map[\""

        acc + param.key() + postfix
    }

    return CodeBlock.builder().apply {
        addStatement("val crdt = %L(%L)", classDeclaration.asType().toClassName().simpleNames.joinToString("."), statement)
        addStatement("return crdt")
    }.build()
}


context(ProcessorContext)
private fun KSValueParameter.key() : String {
    return if(symbols.isCollectionOrArray(type.resolve())) {
        logger.warn("Map key serialization of Composite structs unavailable")
        ""
    } else {
        name?.asString() ?: ""
    }
}


