package com.tap.synk.processor

import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSFile
import com.google.devtools.ksp.symbol.KSType
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.toTypeName
import java.util.Locale


context(ProcessorContext)
internal fun sealedMapEncoderFileSpec(
    packageName: String,
    classDeclaration: KSClassDeclaration,
    originatingFile: KSFile
) : List<FileSpec> {

    val sealedClasses = classDeclaration.declarations.filterIsInstance<KSClassDeclaration>().toList()
    val fileSpecs = sealedClasses.map { sealedClassDeclaration ->

        val fileName = classDeclaration.simpleName.asString() + sealedClassDeclaration.simpleName.asString() + "MapEncoder"
        val genericType = sealedClassDeclaration.asType()

        mapEncoderFileSpec(
            packageName,
            fileName,
            genericType,
            originatingFile
        )
    }

    val compositeEncoder = compositeMapEncoderFileSpec(
        packageName,
        classDeclaration.simpleName.asString()  + "MapEncoder",
        classDeclaration.asType(),
        sealedClasses,
        originatingFile,
    )

    return fileSpecs.plus(compositeEncoder)
}

context(ProcessorContext)
private fun compositeMapEncoderFileSpec(
    packageName: String,
    fileName: String,
    genericType: KSType,
    subEncoders: List<KSClassDeclaration>,
    originatingFile: KSFile,
) : FileSpec = FileSpec.builder(
    packageName = packageName,
    fileName = fileName
).apply {

    val enumName = fileName + "Type"

    indent("    ")
    addFileComment("Code generated by SynkAdapter plugin. Do not edit this file.")
    addType(
        compositeEnum(enumName, subEncoders)
    )
    addType(
        compositeMapEncoder(
            fileName,
            genericType,
            subEncoders,
            originatingFile
        )
    )
}.build()

/**
 * public enum class FooMapEncoderType {
 *     Bar,
 *     Baz,
 * }
 */
context(ProcessorContext)
private fun compositeEnum(
    enumName: String,
    subEncoders: List<KSClassDeclaration>,
) : TypeSpec {
    return TypeSpec.enumBuilder(enumName).apply {
        subEncoders.forEach { encoder ->
            addEnumConstant(encoder.simpleName.asString())
        }
    }.build()
}

context(ProcessorContext)
private fun compositeMapEncoder(
   fileName: String,
   genericType: KSType,
   subEncoders: List<KSClassDeclaration>,
   originatingFile: KSFile,
   ) : TypeSpec {
    return mapEncoderTypeSpec(
        fileName,
        genericType.toTypeName(),
        encodeFunCodeBlock(subEncoders),
        decodeFunCodeBlock(subEncoders),
        originatingFile,
        constructor(subEncoders),
        properties(subEncoders)
    )
}

/**
 * public class FooMapEncoder(
 *     barEncoder: MapEncoder<Foo.Bar> = FooBarMapEncoder,
 *     bazEncoder: MapEncoder<Foo.Baz> = FooBazMapEncoder,
 * )
 */
context(ProcessorContext)
private fun constructor(subEncoders: List<KSClassDeclaration>) : FunSpec {

    val parentDeclaration = subEncoders.first().parentDeclaration as KSClassDeclaration
    val parentName = parentDeclaration.simpleName.asString()

    val parameters = subEncoders.map { declaration ->
        val name = declaration.simpleName.asString()
        val encoderVariableName = "${declaration.simpleName.asString()}Encoder".replaceFirstChar { it.lowercase(Locale.getDefault()) }
        val encoderType = parentName + name + "MapEncoder"
        val type = poetTypes.parameterizedMapEncoder(declaration.asType().toTypeName())
        ParameterSpec.builder(encoderVariableName, type).apply {
            defaultValue("$encoderType()")
        }.build()
    }

    return FunSpec.constructorBuilder().apply {
       parameters.forEach { parameterSpec ->
           addParameter(parameterSpec)
       }
    }.build()
}

/**
 * Adds the property modifiers [PRIVATE, VALUE] to the constructor params
 * public class FooMapEncoder(
 *     private val barEncoder: MapEncoder<Foo.Bar> = FooBarMapEncoder,
 *     private val bazEncoder: MapEncoder<Foo.Baz> = FooBazMapEncoder,
 * )
 */
context(ProcessorContext)
private fun properties(subEncoders: List<KSClassDeclaration>) : List<PropertySpec> {
    return subEncoders.map { declaration ->
        val encoderVariableName = "${declaration.simpleName.asString()}Encoder".replaceFirstChar { it.lowercase(Locale.getDefault()) }
        val type = poetTypes.parameterizedMapEncoder(declaration.asType().toTypeName())
        PropertySpec.builder(encoderVariableName, type).apply {
            initializer(encoderVariableName)
            addModifiers(KModifier.PRIVATE)
        }.build()
    }
}

/**
 * public override fun encode(crdt: Foo): Map<String, String> {
 *      val map = when(crdt) {
 *          is Foo.Bar -> barEncoder.encode(crdt)
 *          is Foo.Baz -> bazEncoder.encode(crdt)
 *      }
 *      val type = when(crdt) {
 *          is Foo.Bar -> FooMapEncoderType.Bar.ordinal
 *          is Foo.Baz -> FooMapEncoderType.Baz.ordinal
 *      }
 *      return map + mutableMapOf("*type" to type.toString())
 * }
 */
context(ProcessorContext)
private fun encodeFunCodeBlock(subEncoders: List<KSClassDeclaration>) : CodeBlock {

    val parentDeclaration = subEncoders.first().parentDeclaration as KSClassDeclaration

    val encoderStatements = subEncoders.map { declaration ->
        val sealedClassName = declaration.simpleName.asString()
        val sealedClassType = parentDeclaration.simpleName.asString() + "." + sealedClassName
        val sealedClassEncoderVariableName = "${sealedClassName}Encoder".replaceFirstChar { it.lowercase(Locale.getDefault()) }
        "is %L -> %L.encode(crdt)" to listOf(sealedClassType, sealedClassEncoderVariableName)
    }

    val typeStatements = subEncoders.map { declaration ->
        val sealedClassName = declaration.simpleName.asString()
        val sealedClassType = parentDeclaration.simpleName.asString() + "." + sealedClassName
        val enumName = parentDeclaration.simpleName.asString() + "MapEncoderType." + sealedClassName
        "is %L -> %L.ordinal" to listOf(sealedClassType, enumName)
    }

    return CodeBlock.builder().apply {

        beginControlFlow("val map = when(crdt)")
        encoderStatements.forEach { (statement, replacements) ->
            addStatement(statement, *replacements.toTypedArray())
        }
        endControlFlow()

        beginControlFlow("val type = when(crdt)")
        typeStatements.forEach { (statement, replacements) ->
            addStatement(statement, *replacements.toTypedArray())
        }
        endControlFlow()

        addStatement("return map + mutableMapOf(\"*type\" to type.toString())")

    }.build()
}

/**
 * public override fun decode(map: Map<String, String>): Foo {
 *      val type = map["*type"]?.toIntOrNull() ?: 0
 *      val foo = when(type) {
 *          FooType.Bar.ordinal -> barMapEncoder.decode(map)
 *          FooType.Baz.ordinal -> bazMapEncoder.decode(map)
 *      }
 *      return foo
 * }
 */
context(ProcessorContext)
private fun decodeFunCodeBlock(subEncoders: List<KSClassDeclaration>) : CodeBlock {

    val parentDeclaration = subEncoders.first().parentDeclaration as KSClassDeclaration

    val statements = subEncoders.map { declaration ->
        val sealedClassName = declaration.simpleName.asString()
        val enumName = parentDeclaration.simpleName.asString() + "MapEncoderType." + sealedClassName
        val sealedClassEncoderVariableName = "${sealedClassName}Encoder".replaceFirstChar { it.lowercase(Locale.getDefault()) }
        "%L.ordinal -> %L.decode(map)" to listOf(enumName, sealedClassEncoderVariableName)
    }

    return CodeBlock.builder().apply {
        addStatement("val type = map[\"*type\"]?.toIntOrNull() ?: 0")
        beginControlFlow("val crdt = when(type)")
        statements.forEach { statementPair ->
            addStatement(statementPair.first, *statementPair.second.toTypedArray())
        }
        addStatement("else -> throw Exception(\"Unknown encoded sealed class type\")")
        endControlFlow()
        addStatement("return crdt")
    }.build()
}