package com.tap.synk.processor

import com.google.devtools.ksp.getAllSuperTypes
import com.google.devtools.ksp.innerArguments
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.symbol.KSVisitorVoid
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.toTypeName
import com.squareup.kotlinpoet.ksp.writeTo

internal class SynkAnnotationVisitor(
    private val synkSymbols: SynkSymbols,
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : KSVisitorVoid() {

    companion object {
        internal fun invariantMustHaveQualifiedName(classDeclaration: KSClassDeclaration) : Boolean {
            return classDeclaration.qualifiedName?.let { true } ?: false
        }
        internal fun invariantMustImplementIdResolver(classDeclaration: KSClassDeclaration, idResolverType: KSType) : Boolean {
            return classDeclaration.getAllSuperTypes().any {
                it.declaration == idResolverType.declaration
            }
        }
    }

    override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {

        if(!invariantMustHaveQualifiedName(classDeclaration)) {
            logger.error(
                "@SynkAdapter must target classes with qualified names",
                classDeclaration
            )
            return
        }

        if (!invariantMustImplementIdResolver(classDeclaration, synkSymbols.idResolver)) {
            logger.error(
                "@SynkAdapter annotated class ${classDeclaration.qualifiedName?.asString()} must implement IDResolver interface",
                classDeclaration
            )
            return
        }

        val customIdResolverType = classDeclaration.getAllSuperTypes().first() { it.declaration == synkSymbols.idResolver.declaration }
        val crdtType = customIdResolverType.innerArguments.first().type?.resolve() ?: return
        val crdtClassName = crdtType.declaration.simpleName.asString()

        val synkPackageName = synkSymbols.synkAdapter.declaration.packageName.asString()
        val mapEncoderPackageName = synkSymbols.mapEncoder.declaration.packageName.asString()
        val customPackageName = crdtType.declaration.packageName.asString()

        val mapEncoderClassName = crdtClassName + "MapEncoder"
        val synkAdapterClassName = crdtClassName + "SynkAdapter"

        val customMapEncoderTypeName = ClassName(mapEncoderPackageName, "MapEncoder").parameterizedBy(crdtType.toTypeName())
        val customSynkAdapterTypeName = ClassName(synkPackageName, "SynkAdapter").parameterizedBy(crdtType.toTypeName())

        val fileSpec = FileSpec.builder(
            packageName = customPackageName,
            fileName = synkAdapterClassName
        ).apply {
            indent("    ")
            addFileComment("Code generated by SynkAdapter plugin. Do not edit this file.")
            addType(
                TypeSpec.classBuilder(synkAdapterClassName)
                    .primaryConstructor(
                        FunSpec.constructorBuilder()
                            .addParameter(
                                ParameterSpec
                                    .builder("idResolver", customIdResolverType.toTypeName())
                                    .defaultValue(classDeclaration.simpleName.asString() + "()")
                                    .build()
                            )
                            .addParameter(
                                ParameterSpec
                                    .builder("mapEncoder", customMapEncoderTypeName)
                                    .defaultValue("$mapEncoderClassName()")
                                    .build()
                            )
                            .build()
                    )
                    .addProperty(
                        PropertySpec.builder("idResolver", customIdResolverType.toTypeName())
                            .initializer("idResolver")
                            .addModifiers(KModifier.PRIVATE)
                            .build()
                    )
                    .addProperty(
                        PropertySpec.builder("mapEncoder", customMapEncoderTypeName)
                            .initializer("mapEncoder")
                            .addModifiers(KModifier.PRIVATE)
                            .build()
                    )
                    .addSuperinterface(customSynkAdapterTypeName)
                    .addSuperinterface(customIdResolverType.toTypeName(), "idResolver")
                    .addSuperinterface(customMapEncoderTypeName, "mapEncoder")
                    .build()
            )
        }.build()

        fileSpec.writeTo(codeGenerator = codeGenerator, aggregating = false)
    }

    override fun visitPropertyDeclaration(property: KSPropertyDeclaration, data: Unit) {
        if (property.type.resolve().isAssignableFrom(synkSymbols.intType)) {
            val name = property.simpleName.asString()
//            summables.add(name)
        }
    }
}